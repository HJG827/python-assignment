'''
[모의 SW 역량테스트] 디저트 카페

친구들과 디저트 카페 투어를 할 계획이다.
[Fig. 1]과 같이 한 변의 길이가 N인 정사각형 모양을 가진 지역에 디저트 카페가 모여 있다.

원 안의 숫자는 해당 디저트 카페에서 팔고 있는 디저트의 종류를 의미하고
카페들 사이에는 대각선 방향으로 움직일 수 있는 길들이 있다.
디저트 카페 투어는 어느 한 카페에서 출발하여
[Fig. 2]와 같이 대각선 방향으로 움직이고 사각형 모양을 그리며 출발한 카페로 돌아와야 한다.

디저트 카페 투어를 하는 도중 해당 지역을 벗어나면 안 된다.
또한, 친구들은 같은 종류의 디저트를 다시 먹는 것을 싫어한다.
즉, [Fig. 3]과 같이 카페 투어 중에 같은 숫자의 디저트를 팔고 있는 카페가 있으면 안 된다.
 
[Fig. 4]와 같이 하나의 카페에서 디저트를 먹는 것도 안 된다.
[Fig. 5]와 같이 왔던 길을 다시 돌아가는 것도 안 된다.
친구들과 디저트를 되도록 많이 먹으려고 한다.
디저트 가게가 모여있는 지역의 한 변의 길이 N과 디저트 카페의 디저트 종류가 입력으로 주어질 때,
임의의 한 카페에서 출발하여 대각선 방향으로 움직이고
서로 다른 디저트를 먹으면서 사각형 모양을 그리며 다시 출발점으로 돌아오는 경우,
디저트를 가장 많이 먹을 수 있는 경로를 찾고, 그 때의 디저트 수를 정답으로 출력하는 프로그램을 작성하라.
만약, 디저트를 먹을 수 없는 경우 -1을 출력한다.

[예시]
한 변의 길이 N이 4인 지역에 디저트 카페가 [Fig. 6]과 같이 있다고 생각하자.

디저트 카페 투어가 가능한 경우는 [Fig. 7]과 같이 5가지로 나눌 수 있다.
(출발한 곳과 도는 방향은 다를 수 있지만, 디저트 카페 투어의 경로가 그리는 사각형 모양은 5가지 중 하나이다.)

[Fig. 7]
 
이 중에 디저트를 가장 많이 먹을 수 있는 경우는 ⑤인 경우로 디저트의 종류는 6개이다.
따라서, 정답은 6이 된다.

[제약사항]
1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초
2. 디저트 카페가 모여있는 지역의 한 변의 길이 N은 4 이상 20 이하의 정수이다. (4 ≤ N ≤ 20)
3. 디저트 종류를 나타나는 수는 1 이상 100 이하의 정수이다.

[입력]
입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 디저트 카페가 모여있는 지역의 한 변의 길이 N이 주어진다.
그 다음 N 줄에는 N * N 크기의 디저트 카페에서 팔고 있는 디저트 종류에 대한 정보가 주어진다.

[출력]
테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t는 1부터 시작하는 테스트 케이스의 번호이다)
출력해야 할 정답은 가능한 경우 중 디저트를 가장 많이 먹을 때의 디저트 수 이다.
만약, 디저트를 먹을 수 없는 경우 정답은 -1이다.
'''
# 입력
'''
10
4
9 8 9 8
4 6 9 4
8 7 7 8
4 5 3 5
5
8 2 9 6 6
1 9 3 3 4
8 2 3 3 6
4 3 4 4 9
7 4 6 3 5
6
1 8 9 6 3 9
5 3 1 9 8 2
6 9 3 4 1 2
7 1 1 5 1 9
1 9 6 8 7 3
7 6 4 5 5 5
7
7 4 1 5 1 7 9
9 4 6 1 4 6 8
9 6 4 8 4 7 4
3 2 6 2 4 2 8
4 9 4 6 2 4 7
1 7 6 8 9 5 8
1 9 4 7 2 9 7
8
18 18 7 16 15 3 5 6
3 6 8 3 15 13 15 2
4 1 11 17 3 4 3 17
16 2 18 10 2 3 11 12
11 17 16 2 9 16 5 4
17 7 6 16 16 11 15 8
2 1 7 18 12 11 6 2
13 12 12 15 9 11 12 18
9
12 3 10 8 11 12 5 3 11
8 6 4 9 8 2 4 7 6
6 10 12 8 3 8 11 3 3
6 10 5 5 5 11 8 10 2
5 13 3 7 5 6 5 12 6
6 1 5 4 4 13 8 7 2
12 7 13 3 5 1 11 7 3
13 12 7 5 6 12 12 9 6
1 12 13 13 11 3 4 10 9
10
18 8 21 24 8 4 20 15 14 23
17 22 3 14 3 19 19 7 6 13
2 26 10 10 10 7 18 14 15 17
13 25 7 20 18 21 8 2 4 24
4 3 1 5 15 3 15 12 22 23
19 22 9 17 6 9 22 26 2 5
12 13 19 13 6 2 12 19 24 8
21 21 24 15 4 1 20 13 14 5
6 10 17 13 7 4 22 16 9 7
17 8 12 11 20 13 5 24 11 3
11
19 1 20 18 8 11 21 11 4 19 14
14 17 6 10 19 3 5 9 18 20 7
4 8 9 3 3 1 3 17 3 19 21
20 19 13 21 20 17 5 21 15 3 10
18 1 7 16 19 21 15 8 7 17 5
21 1 3 11 14 4 15 10 14 15 17
5 15 5 12 16 5 15 14 8 11 5
14 18 2 19 19 8 5 7 11 11 1
20 9 13 8 16 4 21 20 12 16 1
9 11 7 18 5 19 5 18 13 18 20
5 16 1 12 6 15 8 15 3 18 7
14
11 31 22 3 36 20 10 23 6 5 22 22 19 29
9 7 13 9 31 15 7 1 13 33 11 24 7 36
21 22 6 19 23 4 6 21 14 36 9 4 30 21
17 2 30 13 26 36 2 13 32 27 36 5 28 16
8 20 12 16 31 10 32 15 19 24 34 20 1 16
17 18 22 3 10 2 30 26 27 29 10 16 24 12
25 32 31 20 10 29 19 11 32 23 28 20 33 24
9 13 19 4 6 27 24 5 16 2 8 34 2 7
21 5 5 26 2 35 7 36 21 22 23 33 2 6
16 21 15 21 12 11 13 28 3 3 14 23 16 4
1 31 35 33 23 29 12 18 24 25 19 33 17 13
29 6 30 19 33 14 35 14 6 23 27 16 12 24
26 31 30 10 16 21 7 4 16 25 31 19 21 8
12 5 2 4 4 27 29 2 18 20 19 26 32 31
20
11 34 7 49 59 88 79 12 63 38 13 27 9 70 97 92 86 95 84 18
11 84 39 44 86 86 59 52 61 97 81 94 92 78 32 7 5 62 41 75
15 61 71 27 3 4 79 51 95 99 73 27 75 31 4 7 15 51 50 16
6 81 32 61 75 24 36 26 57 55 52 15 35 44 30 25 2 54 12 25
42 4 66 1 23 44 1 7 63 27 82 70 40 45 4 3 12 35 11 85
97 55 69 49 34 79 37 69 89 66 85 22 23 88 24 79 1 48 85 72
4 67 23 3 27 18 37 61 7 68 88 80 35 21 42 88 38 10 81 84
78 86 21 50 46 13 50 9 54 3 1 94 85 75 80 45 31 100 29 70
9 59 7 48 81 82 43 68 90 37 26 41 84 31 58 42 4 96 86 20
22 4 49 94 74 42 6 38 84 90 29 95 84 36 18 4 10 34 71 26
46 43 7 88 18 21 96 57 3 72 52 83 50 53 56 51 19 50 57 6
15 30 88 26 49 10 6 12 98 81 47 88 82 2 68 85 62 12 92 88
100 31 5 15 76 84 39 10 52 61 28 12 50 22 35 85 1 83 2 76
17 27 83 45 18 4 95 37 23 96 58 49 36 47 13 10 41 38 37 6
22 92 59 68 51 15 65 88 18 69 40 49 7 11 78 14 95 94 45 27
13 36 33 22 29 49 11 10 50 91 15 71 87 83 63 26 76 89 28 9
98 9 96 58 72 79 28 9 63 67 85 16 40 66 46 47 17 85 16 99
42 87 28 97 60 89 92 90 51 60 96 22 51 95 55 44 16 9 51 69
27 45 53 43 45 52 12 90 86 91 47 39 84 9 21 77 69 56 5 69
99 47 66 91 71 2 9 26 43 54 52 30 4 94 97 92 2 67 12 85
'''
# 출력
'''
#1 6
#2 -1
#3 4
#4 4
#5 8
#6 6
#7 14
#8 12
#9 18
#10 30
'''


import sys
sys.stdin = open('.txt', 'r')

# GPT 코드입니다... ^^
dr = [1, 1, -1, -1]   # 0: 아래-오른쪽, 1: 아래-왼쪽, 2: 위-왼쪽, 3: 위-오른쪽
dc = [1, -1, -1, 1]

def dfs(r, c, start_r, start_c, d, turns, cnt, dessert_set):
    global ans
    # 현재 위치에서 진행할 방향은 d부터 3까지.
    for i in range(d, 4):
        # 만약 방향을 바꾼다면 turns 증가
        new_turns = turns + (1 if i > d else 0)
        if new_turns > 3:
            continue
        nr = r + dr[i]
        nc = c + dc[i]
        # 범위 체크
        if not (0 <= nr < N and 0 <= nc < N):
            continue
        # 만약 시작점에 도달했고, 4개 이상의 카페를 방문했으며, 정확히 3번의 방향 전환을 했다면
        if nr == start_r and nc == start_c and cnt >= 4 and new_turns == 3:
            ans = max(ans, cnt)
            continue
        # 중복 디저트 검사
        if arr[nr][nc] in dessert_set:
            continue
        dessert_set.add(arr[nr][nc])
        dfs(nr, nc, start_r, start_c, i, new_turns, cnt + 1, dessert_set)
        dessert_set.remove(arr[nr][nc])

ans = -1
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = -1
    # 시작점은 격자 내부에서 선택 (경계 조건 때문에)
    for r in range(0, N-2):
        for c in range(1, N-1):
            dessert_set = set()
            dessert_set.add(arr[r][c])
            dfs(r, c, r, c, 0, 0, 1, dessert_set)
    print(f'#{tc} {ans}')
